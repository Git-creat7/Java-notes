# 插值查找
- 前提是数据有顺序
```Java 
	int[] list = {7,23,79,81,103,127,131,147};  
	int l = 0;  
	int r = list.length - 1;  
	int x = sc.nextInt();  
	int mid;
	while (l <= r && x >= list[l] && x <= list[r]) {
	// 先乘后除
		mid = l + (x - list[l]) * (r - l) / (list[r] - list[l]);

		if (x == list[mid]) {
			System.out.println("找到了，索引为：" + mid);
			break;
		} else if (x > list[mid]) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
```
- **插值查找优点**：对于**均匀分布**的数组，速度极快（时间复杂度接近 $O(\log(\log n))$）。
- **插值查找缺点**：如果数据分布**极不均匀**（比如：`{1, 2, 3, 100, 1000, 10000}`），插值查找的性能可能还不如二分查找。

---
#  冒泡排序
- 相邻的数据两两比较
- `if(a[i] > [j]) swap(a[i],a[j])`
# 选择排序
- 从0索引开始，拿着每一个索引上的元素跟后面的元素一一比较，小的放前面，大的放后面。
- 第一轮循环，确定确定了最小元素
# 插入排序
- 分为有序组和无序组
- 将无序组逐个插入有序组中
```Java
public class TestDemo {  
    public static void main(String[] args) {  
        int[] arr = {4,16,5,9,12,21,18,  
                32,23,37,26,45,34,  
                50,48,61,52,73,66};  
        int startIndex = -1;  
        for (int i = 0; i < arr.length; i++) {  
            if(arr[i] > arr[i+1]){  
                startIndex = i + 1;  
                break;  
            }  
        }  
        if(startIndex == -1){  
            return ;  
        }  
        for(int i = startIndex; i < arr.length; i++){  
            int  j = i;  
            while(j > 0 && arr[j] < arr[j-1]) {//寻找正确的位置
                int temp = arr[j];  
                arr[j] = arr[j - 1];  
                arr[j - 1] = temp;  
                j--;  
            }  
        }  
    }  
}
```

# 递归
- 方法再次调用方法本身
- **递归一定要有出口，否则就会内存溢出**

# 快速排序
- 第一轮：将0索引数字作为基准数，确定基准数在数组中的正确位置
- 




