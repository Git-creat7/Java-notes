# static（静态）

##  静态变量

在JavaBean中，不加static只能供一个对象使用
- 被 static 修饰的变量属于类，所有实例共享同一个变量值
- 在内存中只存在一份，当类被加载时初始化
- 通常用于表示所有对象共有的属性
```Java
public class Student {
    // 静态变量（类变量）
    public static String schoolName = "阳光中学";
    // 实例变量
    private String name;
    
    public Student(String name) {
        this.name = name;
    }
    
    public static void main(String[] args) {
        // 直接通过类名访问静态变量
        System.out.println(Student.schoolName); // 输出：阳光中学
        
        Student s1 = new Student("张三");
        Student s2 = new Student("李四");
        
        // 也可以通过实例访问（不推荐）
        System.out.println(s1.schoolName); // 输出：阳光中学
        
        // 修改静态变量，所有实例都会受到影响
        Student.schoolName = "星光中学";
        System.out.println(s2.schoolName); // 输出：星光中学
    }
}	
```
>[!NOTE]
>JDK8之前，静态区处于方法区里面。
>JDK7之后，静态区处于堆空间之中。


## 静态方法
- 多用在测试类和工具类当中
- JavaBean中很少用

> [!NOTE]
>JavaBean类：用来描述一类事物的类
>测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口
>工具类：不是用来描述一类事物的，而是帮我们做一些事情的类
> 

### 工具类
1.类名见名知意
2.私有化构造方法
```Java
    public class ArrUtil{
        private ArrUtil(){}
    }
```
    private ArrayUtil() {} 是一个私有构造方法
    由于构造方法被声明为 private（私有），这意味着在类的外部无法调		用这个构造方法，也就无法创建 ArrayUtil 类的对象实例。
**防止这个工具类被意外地实例化**
>[!NOTE]
>如果不写这个私有构造方法，Java 会默认提供一个公共的无参构造方法
>这样别人就可能误将其当作普通 JavaBean，写出new ArrayUtil()这样的代码（虽然创建了对象也没用，但不符合设计意图）

3.方法定义为静态

---

## static的注意事项
- 静态方法只能访问静态变量和静态方法
- 非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法
- 静态方法中没有this关键字


```Java
public class Student{
	String name;
	int age;
	static String teachername;
	
	//this:表示当前方法调用者的地址值
	//这个this:是由虚拟机赋值的
	public void show1(Student this){//此处的this是虚拟机暗加的
		sout("this:" + this);//地址值
		sout(name+","+age+","+teachername);
		//实际上是this.name和this.age和this.teachername
		
		show2();
		//实际上是this.show2();
		//意思是当前show1调用的对象继续调用show2
		
	}
	
	public void show2(){}
	poublic static void method(){//此处的静态方法却不会有this关键字
		//不可调用非静态的成员变量和成员方法
		sout("静态方法");
	}
	

}

public class StudentTest(){		
	public static void main(String[] args){
		Student.teachername  = "老师姓名";
		
		Student s1 = new Student();
		sout("s1:" + s1);//地址值
		s1.name = "张三";
		s1.age = 23;
		s1.show1(); //此处的s1对应this
		
		Student s2 = new Stduent();
        sout("s2:" + s2);//地址值
		s2.name = "李四";
		s2.age = 24;
		s2.show1();//此处的s2对应this
		
	}
}
```
打印后，s1与this的地址值相同，s2与this的地址相同。
### 内存的加载
静态：随着类的加载而加载
非静态：与对象有关 

### main方法
```Java
	public class HelloWorld{
		public static void main(String[] args){
			//[]：数组
			//String:数据类型
			//args：数组名
			sout("HelloWorld");
		}
	}
```
-  **public：被JVM调用，访问权限足够大**
-  **static：被JVM调用，不用创建对象，直接类名访问。**
-  **因为main方法是静态的，所以测试类中的其他方法也需要是静态的**
-  **void：被JVM调用，不需要给JVM返回值**
-  **main：一个通用的名称，不是关键字，但是被JVM识别**
-  **String[] args：以前用于接受键盘录入数据，现在没用**


---

# 继承
- **Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起 <u>继承关系</u>**  
`public class Student extends Person{}`
- **Studet成为子类（派生类），Person称为父类（基类或超类）。**
	使用继承的好处：
	- 可以把多个子类中重复的代码抽取到父类中了，提高代码的复用性
	- 子类可以在父类的基础上，增加其他的功能，使子类更强大。

**？什么时候用继承：**
	**当类与类之间，存在相同（共性）的内容，并满足子类是父类的一种，就可以考虑用继承，来优化代码。**

---

# 继承特点
**Java只支持单继承，不支持多继承，但支持多层继承。**
- **单继承：一个子类只能继承一个父类**
- **不支持多继承：子类不能继承多个父类**
>[!NOTE]
>每一个类都直接或间接继承于Object

> [!WARNING]
> 1. 构造方法不可被继承 
> 2. 成员变量私有和非私有都能被继承（私有不可直接使用）
> 3. 成员方法只有**非私有非static非final**（能被加入虚方法表）能被继承
>

## 在继承中 成员变量的访问特点

**就近原则**
```Java
public class Fu{
	String name = "Fu";
}
public class Zi extends Fu{
	String name = "Zi";//若没有此语句会打印Fu
	public void ziShow(){		
		String name = "ziShow";//若没有此语句会打印Zi
		sout(name); //ziShow...依次向上找name
	}
}
```

```Java
public class Fu{
	String name = "Fu";
}
public class Zi extends Fu{
	String name = "Zi";
	public void ziShow(){		
		String name = "ziShow";
		//局部->本类->父类
		sout(name); //ziShow
		sout(this.name);//Zi
		//this:本类
		sout(super.name);//Fu
		//super:父类
        }
}
```
> [!IMPORTANT]
> **name：从局部位置开始往上找... 局部 --> 本类 --> 父类**
> **this.name：从本类成员位置开始往上找... 本类 --> 父类**
> **super.name：从父类成员位置开始往上找...父类**


## 在继承中成员方法的访问特点
**直接调用满足就近原则，super调用直接访问父类**
方法的重写：
 <u>**当父类的方法不能满足子类现在的需求时，需要进行方法重写**</u>

书写格式：
 **在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。**
@Override重写注解
 **@Override是放在重写后的方法上，校验子类重写时语法是否正确。**

### 方法重写的本质

A类-------继承------>B类---继承--->C类

<u>**子类覆盖了从父类继承下来的虚方法表里的方法**</u>

| 写入方法 | A（method2）       | B（method2）       | C（method1，method2） |
| -------- | ------------------ | ------------------ | --------------------- |
| 虚方法表 | C：method1         | C：method1         | C：method1            |
|          | A：method2（）重写 | B：method2（重写） | C：method2            |



>[!NOTE]
>**1.重写方法的名称、形参列表必须与父类中的一致**
>**2.子类重写父方法时.，访问权限子类必须大于等于父类（空 < protected < public）**
>**3.子类重写父类方法时，返回值类型必须小于等于父类**
><u>**4.重写的方法尽量和父类保持一致**</u>
>**5.只有被添加到虚方法表中的方法才能被重写**

---

## 在继承中构造方法的访问特点

- 父类中的构造方法不会被子类继承，但是可以使用super调用。
- 子类中所有的构造方法默认先访问父类中的无参构造，在执行自己。（子类构造方法第一句默认是super()，不写也存在，若想调用父类有参构造，则必须使用super）
- 如果想要访问父类的有参构造，必须手动书写

## this 与 super
**this:理解为一个变量，表示当前方法调用者的地址值。**
**super:代表父类存储空间。**

| 关键字    | 访问成员变量                      | 访问成员方法                      | 访问构造方法                        |
| --------- | --------------------------------- | --------------------------------- | ----------------------------------- |
| **this**  | this.成员变量---访问本类成员变量  | this.成员方法---访问本类成员方法  | <u>this(...)---访问本类构造方法</u> |
| **super** | super.成员变量---访问父类成员变量 | super.成员方法---访问父类成员方法 | super(...)---访问父类构造方法       |



**this()：**

```Java
class Student{
    String name;
    int age;
    String school;
    Student(){
    	//表示调用本类的其他构造方法
    	//虚拟机不会再添加super();
        this(null,0,"默认大学");
    }

    public Student(String name, int age, String school) {
    	//因为调用之后此处有一个super();
        this.name = name;
        this.age = age;
        this.school = school;
    }
}
```

# 多态

**同类型的对象，表现出不同的形态**
**表现形式：**`父类类型 对象名称 = 子类对象;`
前提：1.**有继承/实现关系	2.有父类引用指向子类对象	3.有方法重写**
好处：使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。
```Java
public class Test {
    public static void main(String[] args) {
        Student s = new Student("张三",18);
        Teacher t = new Teacher("王建国",22);
        Admin a = new Admin("管理员",20);

        register(s);
        register(t);
        register(a);
    }
    //接收老师，学生，管理员
    public static void register(Person p){
    	//在每一个子类中都重写了show方法
    	//p.show()，会直接指向子类的方法
        p.show();
    }
}

```

## 多态调用成员变量的特点
	`父类类型 对象名称 = 子类对象;`
- **变量调用：编译看左边，运行也看左边**
```Java
	//Animal 默认name为"动物"
	//Dog 默认name为"狗"
	Animal a = new Dog();
	//编译看左边：Javac编译代码的时候，会看左边的父类有没有这个变量，如果有，编译成功，反之失败
	//运行也看左边：Java运行代码的时候，实际获取的就是左边父类中成员变量的值
	sout(a.name);//动物
```

- **方法调用：编译看左边，运行看右边**
```Java
	Animal a = new Dog();
	//编译看左边：Javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，反之失败
	//运行看右边：Java运行代码的时候，实际上运行的是子类中的方法
	a.show();//Dog---show方法
```



